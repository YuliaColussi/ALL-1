
--------------
SYMFONY :
--------------




INTRO: qu'est-ce que SYMPHONY
Etape 1 : Installation de SYMPHONY 3.4
LTS : Long Time Support
Etape 2 : Les bundles
Etape 3 : Les routes et les controllers
Etape 4 : Cr√©er la boutique en SYMPHONY
Etape 5 : TWIG(moteur de template)
Etape 6 : Les assets
Etape 7 : Entit√©s
Etape 8 : DOCTRINE
Etape 9 : Les formulaires
Etape 10 : Validation des donn√©es
Etape 11 : Assosiation mapping
Etape 12 : S√©curit√© et Utilisateurs
Etape 13 : Installation et boutique sur SF 4.3
BONUS : Formulaire de contact
BONUS : Panier


-------------------------------------------------
INTRO: qu'est-ce que SYMPHONY
-------------------------------------------------

1.  What is the interest of using a framework?

    A. We have an organised structure
    B. Fonctionnalit√© commune √† tous les projets - we make code once and then reuse it like a subscription or a connection form 
    C. Service disponibles(Routing, S√©curit√©, BDD, Moteur de template, formulaire...)
    D. Communaut√© - it's a society cuz there is always another people who specialise on this framework


2. How to choose a framework.

    A. Or to make your own framework;
    B.Les framework fullstack (Symfony, Zend, Laravel, cake)
    C. Les mini Framework (Silex, Slim, CodeIgniter, Lumen...)



3. We talk about SYMFONY

--> Symfony is a French framework created by Sensiolabs  
--> versions :
    LTS (Long Time Support): 
        v 2.8
        v 3.4 : 2.8 plus souple (moins rigide), avec des fonctionnalit√©s
        v 4.4 : 3.4 BundleLess, Flex, Encore (webpack bibliotheque), Maker, PHP7.1


Etape 1 : Installation de SYMPHONY 3.4
Sommaire :
1. Installer Composer
2. Installer SF3.4
-on va dans le dossier Symfony and click droit -> open Git Bush and write 'composer'


1. Installer Composer

Composer est un outils de d√©pendance. Composer allows us to know when its an update and it will update all of them concirning the changes

- T√©l√©charger : https://getcomposer.org/download composer-Setup.exe

- Installer : Suivre les √©tapes.


<cmd>
composer create-project symfony/framework-standard-edition test

==> A ce stade un dossier test √† √©t√© cr√©√©. C'est un nouveau projet SF.

3. rdorescence des dossiers et fichiers

- app/ contient toute la configuration de l'app (BDD, s√©curit√©, routes...)
-bin/ : Les √©x√©cutable de l'app (de SF)
-src/ : Le dossier dans lequel nous allons coder notre MVC
-var/ : Les fichiers √©crits par SF au fur et √† mesure (cache, logs)
-tests/ : Les tests unitaires
-web/ : repertoire WEB (app.php ou app_dev.php, img/css/js/fonts) thats where internet will come
-vendor/ le codeur de SF (les fichiers cod√©s par les sensioLabs)

-composer.json : Contient la list de toutes les d√©pendances dont on a besoin.






3.Arborescence des dossiers et fichiers


4/ Lancement de l'application

    - M√©thode 1 : 
    localhost/Back/SYMFONY/test/web/app.php
    localhost/Back/SYMFONY/test/web/app_dev.php

    - M√©thode 2 :
    On va dans le dossier test/
    <cmd>
    php bin/console server:run 

    localhost:8000

    - Diff√©rences entre mode prod et dev :
    localhost/Back/SYMFONY/test/web/toto -prod
    localhost:8000/toto - dev



-------------------------------------------
ETAPE 2 : Les Bundles
Sommaire : 
1/ Le concepte des Bundles
2/ Cr√©ation de notre premier Bundle
-------------------------------------------


1/ Le concepte des Bundles

    - Les Bundles sont des briques de notre applications.

    UserBundle :
        UserController (C)
        UserModel (M)
        View : inscription/connexion/profil...
    
    Avec la nouvelle version de SF (4), on consid√®re qu'il est pr√©f√©rable de cr√©e un seul bundle (AppBundle).

2/ Cr√©ation de notre premier Bundle

    On va cr√©er un Bundle : POLES/TestBundle

    <cmd>
    php bin/console generate:bundle
    -> Yes
    -> POLES/TestBundle
    -> POLESTestBundle
    -> src/
    -> annotation

    ==> Notre bundle a √©t√© bien cr√©e, mais il faut l'enregistrer.

       "psr-4": {
            "AppBundle\\": "src/AppBundle",
            "POLES\\": "src/POLES"
        },
    "POLES\\": "src/POLES" dans le composer.json lignes 9

    - Mise √† jour de l'app
    <cmd>
    composer update


==> Notre Bundle exists dans src/POLES/TetsBundle 
Il est compos√© de 4 dossiers :
    - Controller : les controllers de bundle
    - DependencyInjection : Injection de d√©pendances
    - Resources : Vues et Routes (YML) et eventuellement JS
    - Test : Test li√©s fonctionnalit√© du Bandle


==> A ce stade le Bundle est fonctionnel, mais il y a une petite erreur qu'on va corriger.

    - src/POLES/TestBundle/Controller/DefaultController.php

    <code>

    in src->Controlelr->DefaultController.php first line we changed for the second
    
        // return $this->render('POLESTestBundle:Default:index.html.twig');
        return $this->render('@POLESTest/Default/index.html.twig');
    
    </code>

==> A ce stade la page d'accueil affiche "Hello World"


-----------------------------------------------------------

Etape 3 : Les routes et les controllers

Sommaire :

1. Cr√©ation de routes
2. L'objet Request
3. L'objet Response
4. Redirection
5. Message

----------------------------------------------------------


1/ cr√©ation de routes
	("/") -> route simple homepage
    ("/bonjour/") -> route echo (erreur)
    ("/bonjour2/") -> route response
    ("/hello/{prenom}") -> route response + param URL
    ("/hola/{prenom}") -> route render de vue (html.twig) + param URL
    ("/ciao/{prenom}/{age}") -> route render de vue + 2 params URL
    ("/redirect/") -> route avec redirection (RedirectResponse)
    ("/redirect2/") -> route avec redirection (redirectToRoute())
    ("/message/") -> route avec redirect et message en session


2/ L'objet Request 
	<code>
	use Symfony\Component\HttpFoundation\Request;

	Correspond √† la partie requete de la requ√™te HTTP. 

	<code>
	$session = $request -> getSession(); 
	--> r√©cup√®re la session ($_SESSION)

	Autres exemples : 
	<code>
	$session -> set('prenom', 'Yakine');
	echo $session -> get('prenom'); 

	Autre m√©thode :
	<code>
	$request -> session -> set('prenom', 'Yakine'); 

	
	Autres utilit√©s de $request : 
	<code>
	$request -> query -> get('argument_url');
	$request -> request -> get('champs_form');
	$request -> cookies -> get('cookie');
	$request -> server -> get('server');
	
3/ L'objet Response

	- Correspond √† la partie r√©ponse d'une requ√™te HTTP. 
	
	<code>
	use Symfony\Component\HttpFoundation\Response;
	
	- Toute action (fonction) doit avec une r√©ponse. 
	
	<code>
	return new Response('toto');
	
	- M√™me la fonction render est une r√©ponse. 
	
	<code>
	return $this -> render();
	return $this -> getTemplating() -> renderResponse(); 
	
	
4/ Redirection

	<code>premiere m√©thode : 
	use Symfony\Component\HttpFoundation\RedirectResponse;
	
	cf route "/redirect/" et "/redirect2"
	
	/!\ A ce stade toutes nos routes doivent avoir un name
	
5/ Message
	
	<code>
	$session -> getFlashBag() -> add();

	-> permet d'enregistrer des messages qui seront disponibles dans d'autres pages (messages de f√©licitations, ou d'erreur).
	
	-> app.session : Qui nous permet en Twig de r√©cup√©rer les infos en session. 
	-> app.user : Qui nous permet en Twig de r√©cup√©rer les infos de l'utilisateur actuellement connect√©





----------------------------------------------------------------

Etape 4 : Cr√©er la Boutique sur SF 3.4
Sommaire :

1. Cr√©ation du projet

- Dans le dossier Symfony

<cmd>

composer create-project symfony/framework-standard-edition Boutique3 
cd Boutique3

php bin/console/server:run

Test: localhost:8000



2. R√©organiser le AppBundle

localhost/ -> Produit/index.html.twig
localhost/categorie/pull -> Produit/index.html.twig
localhost/produit/12 -> Produit/show.html.twig

--> Cr√©ation de nos Controllers:
    AdminController
    MembreController
    CommandeController
    ProduitCotroller
    --
    SecurityController
    ProduitController

--> cr√©ation de nos Vues
    Admin/ (list_produit, form_produit)
    Membre/ (connexion, inscription, profil)
    Commande/ (panier, transport, livraison, paiement)
    Produit/ (home, categorie, boutique, fiche_produit)



3. Cr√©ation des premi√®re route

    -> ProduitController : /, /produit{id}
    -> AdminController : "/admin/produit/", "/admin/membre/"


----------------------------------------------------------------

ETAPE 5 : TWIG (moteur de template)
Sommaire :
1. Cr√©ation du layout
2. L'h√©ritage Twig
3. Modification de nos Vues
4. Documentation Twig

----------------------------------------------------------------

TWIG est le moteru de template de Symfony.
Un moteur de template (tpl, smarty, Twig, blade...) permet d'afficher du php dans le vues HTML de mani√®re plus simple.

    exemple :
    <?= $membre['prenom'] ?>
    {{ membre.prenom }}


    1. Creating du layout

    Chemin : Boutique3/app/Resources/views/layout.html.twig - we can create it only here 

    Un layout est une structure de page, dans laquelle on peut ajouter des √©l√©ments contenu.
    Le concept de layout permet d'avoir pluisieurs structures de pages dans noter site (ex: front vs backoffice)

    2. H√©ritage Twig

    Avec Twig on parle d'h√©ritage. Cela signifie que nos vues h√©ritent (extends) d'un layout, et peuvent contenit de l'HTML √† l'int√©rieur des blocks disponibles (cr√©√©s dans le layout).
    
=====> De mani√®re g√©n√©rale, il faut voir le fonctionnement de Twig et de la m√©thode render comme un chargement du contenu de mani√®re "empil√©e" (analogie de la poup√©e russe). Render temporise (m√©moire tempon) le contenu, et affiche en meme temps le layout, la vue et les params.

    3. Modification de nos vues
    <code>

    {% extends 'layout.html.twig' %}

    {% block content%}

    <h2>HTML ICI/h2>

    {% endblock %}

    /!\ ATTENTION : Quand on utilise l'h√©ritage Twig, nos vues ne peuvent contenir de l'HTML qu'√† linterieur des blocks pr√©vus pour.

    4. Documentation Twig

    https://twig.symfony.com/doc/2.x/

===> A ce stade notre app permet d'afficher les pages accueil, inscription, connexion, profil, boutique, produit, categorie, gestion membre, gestion produit, gestion commande.

===> Par contre nous ne sommes pas encore en mesure d'√©changer avec la BDD (ajouter un contenu, et r√©cup√©rer le contenu). Il faut voir les Entity et Doctrine.


    ------------------------------------
    ETAPE 6 : ASSETS
    ------------------------------------

    Sommaire: 
        1. Modification du fishier composer.json
        2. Mise √† jour de l'app
        3. Dossier Web/ (photo, css, js...)
        4. Modification de vues

    
    1. Modification du fishier composer.json


    - Le composant Asset de SF nous permet de g√©rer les resources (img, js, fonts.....) et de les appeler de mani√®re absolue.
<code> composer.json

"require": {
    "symfony/asset" : "^3.4"
}

  2. Mise √† jour de l'app

  <cmd>

  composer update


  3. Dossier Web (photo, css, js...)

    Boutique3/web

        photo /(√† r√©cup√©rer du site en proc√©dural)
        js/
        css/


    4. Modification de vues

        href="../../css/styles.css"

        -> href="{{ asset('css/styles.css') }}"

        href="inscription.php"
        -> href="{{ path('inscription') }}"

        La fonction asset() de twig nous permeet de charger une resouce (photo, css, js, fonts...).

        La fonction path() de TWIG nous permet de cr√©er un lien vers une pgae (route). 

        liens dynamiques :

        src="../../photo<? $pdt['photo'] ?>"
        src="{{ asset('photo/' ~ pdt.photo ) }}

        href="fiche_produit.php?id=<?= $pdt['id'] }) }}"

            produit --> nom de la route
            id ---------------> parametre dynamique de la route
            pdt.id ---> valeur du parametre dynamique

    ------------------------------------
    ETAPE 7 : ENTITIES
    ------------------------------------
    sommaire:
    1. Doctrine ORM et le concept des Entit√© (Entity) (object)

        - D'une certaine mani√®re, les entit√©s correspondent √† la partie MODEL de notre MVC. C'est la relation avec le BDD, mais en PHP et non de SQL.
        - Th√©oriquement, nous n'avons plus besoin du SQL.

        - ORM : Object Relation Mapping 

        - Nous allons cr√©√© nos entit√©s, sous forme de classes PHP (POPO : Plain Old PHP Object), qui vont permettre √† Doctrine de comprendre notre BDD et de la manipuler.

        Par exemple, pour faire INSERT INTO Produit on faire

        $produit = newProduit;
        $em -> persist($produit);

        or remove($produit) for deleating

        createForm($produit);

===> Pour que cela soit possible, il faut expliquer √† Doctrine, quel est relation il existe entre la BDD et nous Entity.
    2. Creation Entit√©s Produit


    A. Cr√©er le dossier src/AppBundle/Entity
    B. Cr√©er le fichier src/AppBundle/Entity/Produit.php
    C. Cr√©er notre class Produit et nos propri√©t√©s et les getters et les setters

    3. Annotations (mapping)

    - Avec DOCTRINE  ORM, on param√®tre le mapping via les annotations.

    <code>

    use DOCTRINE\ORM\Mapping as ORM

    --> Voir le fichier Entity/Produit.php

    /!\ Attention : Les annotations pour l' ID (primary key) sont plus longues

    Liens : 

    BASIC MAPPING:

    https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/basic-mapping.html

    ASSOCIATION MAPPING : chapitre 11

    https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/association-mapping.html

    
    
    4. Mettre √† jour la BDD

     <cmd>

    php bin/console doctrine:schema:update --dump-sql

    --> voir la requete

    php bin/console doctrine:schema:update --force

    --> ex√©cute les modifs en BDD

    ==> Permet aussi de cr√©er un eBDD √† partir de nos entites


    5. G√©n√©rer les Entit√©s en ligne de commande

    A. On doit conencter notre app (projet SF) √† la BDD
    -app/Config/parameters.yml

    B. 
    <cmd>
    php bin/console doctrine:generate:entity

    AppBundle:Membre
    -> On suit les √©tapes.

    ===> Cela a cr√©e le fichier Entity/Mmebre.php en quelques lignes de commandes.


    6. G√©n√©rer la BDD via les entites

    - On peut cr√©er la BDD, depuis les entit√©s d√©j√† cod√©es

    <cmd>
  
    php bin/console doctrine:schema:update --force

    --> cr√©er les tables dans la BDD. Par contre il faut que la BDD exists d√©j√†.

    7. G√©n√©rer les √©ntit√©s depuis la BDD

    - On peut cr√©er la BDD, depuis les entit√©s depuis la BDD

      <cmd>
  
   php bin/console doctrine:mapping:import AppBundle\Entity annotation --path=src/appBundle/Entity

    ==> Cette commande nous a premis de g√©n√©rer les Entit√©s depuis le tables de la BDD.
    - Par contre cela n'a ni g√©n√©r√© les repository, ni les getters et setters
    <code>

    A ajouter dans chaque Entity
    
    @ORM\Entity(repositoryClass="AppBundle\Repository\ProduitRepository")
    @ORM\Entity(repositoryClass="AppBundle\Repository\MembreRepository")
    @ORM\Entity(repositoryClass="AppBundle\Repository\CommandeRepository")
    @ORM\Entity(repositoryClass="AppBundle\Repository\DetailsCommandeRepository")

    <cmd>
    php bin/console doctrine:generate:entities AppBundle
    ==> Cela nous cr√©er nos getter et detter et g√©n√®re les repository :)


    2. Cr√©er Entit√© Produit
    3. Annotations (mapping)
    4. Mettre √† jour la BDD
    5. G√©n√©rer les Entit√©s en ligne de commande
    6. G√©n√©rer la BDD via les Entit√©s
    7. G√©n√©rer les entit√© depuis la BDD

   --------------------

   DOCTRINE

   --------------------

   Sommaire :
   1. La service Doctrine
   2. Acc√©der au service doctrine depuis les controllers3. 
   3. Requetes SELECT * FROM ...
   4. Requetes SELECT * FROM ...WHERE id...
   5. Requetes SELECT * FROM ...WHERE ... = ...
   6. Requetes INSERT / update
   7. Requetes DELETE 
   8. Create Query et Query Builder

   --------------------------------------

      1. La service Doctrine

      Doctrine fait 2 choses :

        1. ORM (Object Relation Mapping)
        Il permet de lier les tables de notre BDD √† nos entit√©s. On ne va pas manipuler la BDD, mais des objets (la table Produit ---> EntityProduit)

        2. Doctrine DBAL (Database Abstract Layer)

        Le DBAL est couche qui passe au-dessus de PDO. A partir de maintenent on ne fait plus de requete SQL, mais on va manipuler du PHP.

        - En r√©sum√© le DBAL va nous permettre de faire des SELECT, INSERT, UPDATE, DELETE, non pas via du SQL, mais via des fonction PHP. On parle de DQL (Doctrine Query Language)


        --> NOUS NE FERONS PLUS DE SQL (ou presque) 

    -----------

   2. Acc√©der au service doctrine depuis les controllers3. 

   A. Il faut pouvoir manipuler les entit√©s dont on a besoin.
   <code>

   use AppBundle\Entity\Produit;

   B. Acc√©der au repository dans un controller :
   <code>

   $repo = $this -> getDoctrine() -> getRepository(Produit::Class);

   C. Acc√©der au Manager (Qui peut faire les requetes sur toutes les tables)
   $em = $this -> getDoctrine() ->getManager();

    -----------

   3. Requetes SELECT * FROM ...

   Depuis le repository : 
   <code>

    $repo = $this -> getDoctrine() -> getRepository(Produit::Class);
    $produits = $repo -> findAll();

    ------------

    4. Requetes SELECT * FROM ...WHERE id...

    Depuis le repository: 

    <code>
    $repo = $this -> getDoctrine() -> getRepository(Produit::Class);
    $produits = $repo -> find($id);


    Depuis le Manager: 

    <code>
    $repo = $this -> getDoctrine() -> getManager();
    $produits = $repo -> find(Produit::class, $id);


      5. Requetes SELECT * FROM ...WHERE ... = ...

      La fonction findBy() va nous permettre de r√©cup√©rer des donn√©es de mani√®re plus cibl√©e.
      <code>
       $repo = $this -> getDoctrine() -> getRepository(Produit::Class);
         $produits = $repo -> findBy(array('categorie' => $cat));

         $produits = $repo -> findBy(array(
             'categorie' => 'pull',
             'taille' => 'l'
             ));

             SELECT * FROM produit WHERE taille = 'l' AND categorie = 'pull' - its like this requete
             $produit = $repo ->findBy(['couleur' => rouge], ['prix' => 'DESC'], 0, 10); - its the same thing as above

             we take all the red, where 'order by' price and we have 10 on a page (and on the second page it would be 20, 10)

             SELECT * FROM produit WHERE couleur = 'rouge' ORDER BY prix DESC LIMIT 0,10


             $produit = $repo -> findOneBy(array('taille' => 'l'));
             SELECT * FROM produit WHERE taille = 'l' LIMIT 0,1

    6. Requetes INSERT / UPDATE

        -   Avec doctrine on manipule des Objets (Entit√©)

        -> Enregistrement :
            - On cr√©√© un objet vide.
            - On hydrate l'objet (normallement via un formulaire)
            - On presist et on flush

            <code>
            $produit = newProduit;
            $produit -> setTitre('dgdfg');
            $produit -> setReference('ddd');

            ...

            $em -> persist($produit);
            $em -> flush();


        -> Modification 

            - Pour update une entr√©e, c'est la meme chose que pour ADD, √† ceci pr√®s que l'objet n'est pas vide √† la base. On doit donc r√©cup√©rer l'objet √† modifier avec le fonction find()

        -> Suppression DELETE

            - Avec Doctrine on manipule des Objets (Entit√©) donc on va r√©cup√©rer d'abord l'objet √† supprom√© avec le fonction find().

            <code>
            $em -> remove($produit);
            $em -> flush();


    8. Create Query et Query Builder // we can not do everything with Doctrine so sometimes we need to use our requetes

    SELECT DISTINCT(categorie) FROM produit


    // A faire la guestion des produits :

    AdminController
    -> /admin/produit/

    $produits qui va r√©cup√©rer tout les produits du site

    -> list_produit.html.twig
    -> tableau avec tous les infos des produits
    -> action : modifier / supprimer

Pour effectuer des requete specifiques, nous avons 2 possibilit√©s: thats when we cant use Doctrine

- Create Query (SQL)
- Query Builder (PHP)

==> Voir ProduitRepository
/!\ Dans l'objectif de "factoriser" notre code nous cr√©ons nos requetes sr√©cifiques dans le Repository, afin de les utiliser de mani√®re simple dans les controller.

==> Voir le ProduitController, route /categorie/ et le fonction GetAllCategories() d√©clar√©e dans le ProduitRepository.

liens: 

Query Builder: 

https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/query-builder.html

Create Query:

https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/dql-doctrine-query-language.html




-----------------------------------------------------------

ETAPE 9 : les formulaaires
Sommaire :

1. Le fonctionnement des formulaires
2. G√©n√©rer les formulaire
3. R√©cup√©rer les donn√©es du formulaire
4. Personnaliser un formulaire avec Bootstrap
5. Update un Enregistrement
6. Validation des donn√©es
7. Champs fonctionnel
---------------------------------------------


1. Le fonctionnement des formulaires

- De la meme qu'on ne manipule pas des enregistrements en BDD, mais bien des objet (Entity), chaque formulaire va etre li√© √† une entit√©.

- Ainsi un formulaire est li√© √† un objet...

Inscription -------> objet? (class Membre)
Ajout de produit-------> objet? (class Produit)
Modif de produt -------> objet? (class Produit)


Un formulaire est g√©n√©rer grace √† une classe (Type --> ProduitType)
Chaque champ d'un formulaire correspond √† une classe, service de Symfony.

Cela permet de g√©n√©rer tous les controles sur les formulaires.


2. G√©n√©rer les formulaire

<cmd>

php bin/console generate:doctrine:form AppBundle:Produit

===> Cela cr√©√© un dossier Form dans notre Bundle, et un fichier ProduitType.php, qui contient la construction du formulaire.

3. R√©cup√©rer les donn√©es du formulaire

A. G√©n√©rer le form dans la route
<code>

use AppBundle\Form\ProduitType
$form = $this -> createForm(ProduitType::class, $produit);



B. Afficher la vue du formulaire dans la vue

-On envoie le formulaire √† la vue via les params
<code>

$params = array('produitForm' => $form -> createView())

- On affiche le formulaire :
<code>

{{ form(produitForm) }} --> affiche tout le formulaire
---
{{ form_row(produitForm.reference) }} --> affiche un champs(label, champs, errors)
---
{{ form_label(produitForm) }} --> affiche le label
{{ form_widget(produitForm) }} --> affiche le champs
{{ form_errors(produitForm) }} --> affiche les erreurs





/!\ Si on affiche les champs un par un, il ne faut pas oublier:

{{ form_start(produitForm) }}
{{ form_end(produitForm) }}



C. R√©cuperer les donn√©es saisies

$form -> handleRequest($request);
/!\ Cette ligne est importante pour pouvoir r√©cup√©rer les donn√©es en POST !!


D. Checker la validit√© du form et traiter les donn√©es (enregistrement)

<code>

if($form -> isSubmitted() && $form -> is valid()) { 

    // persist
    //flush
    // message de Validation
    //redirection
}

4. Personnaliser un formulaire avec Bootstrap

<code>app/Config/config.yml
twig:

form_themes:
    -'bootstrap_4_layout.html.twig'


5. Update un enregistrement
Pour update un enregistrement avec les syst√®me des formulaires sur SF, sien de plus simple. Lorsqu'on cr√©√© le formulaire dans la route, on pr√©cise un objet d√©j√† existant. (cf route admin/produit/update/{id}).


----> On dit qu'on hydrate le formulaire.


6. Validation de donn√©es

    - De base le formulaire est g√©n√©r√© par SF de mani√®re basique. Pour g√©rer nous-meme les containts, et le s√©curit√©, cela se passe dans le fichier ProduitType.php, et on utilise 'constraints'pour definir les constraints li√©es au formulaire.


     
7. Champs file

Pour la gestion de photoes il faut:

1. Enregistrer le nom de la photo dans la BDD
2. Enregistrer le photo (data) sur le serveur

==> CF fonction uploadFile() dans l'entity Produit.

/!\ Dans notre formulaire d'ajout de produit il n'est plus necessaire d'avoir le champs photo (TEXT), mais bien un champs file (FILE) qui va √©cup√©rer les infos de la photo upload√©e.


Pour aller plus loin avec le formulaire de Symfony :

https://symfony.com/doc/current/reference/forms/types.html


-----------------------------------------------------------
Etape 10 : Validation des donn√©es :
Pour aller plus moin avec la validation des donn√©es et Symfony :
------------------------------------------------------------

https://symfony.com/doc/current/validation.com




ALL THE CONTROLLERS NEED A REQUEST AT LEAST ONCE


A faire : Inscription:

1. Entity Membre - done
2. Controller : MmebreController ---> Route"/inscription" - done
3. Formulaire (MembreType) --> console - done
4. Route : Cr√©er le formulaire et sa vue - done
5. La vue : afficher le formulaire - done
6. Route : R√©cup√©rer les infos du formulaire et enregistrer le membre


Attention : Etant donn√©e que le champs Statut existe dans notre BDD, le formulaire va etre cr√©er avec un champs Statut, hors ce n'est pas au membre de choisir son statut 

-----------------------------------------------------------
Etape 11 : ASSOCIATIOON MAPPING
----------------------------------------------------------

-----------------------------
Etape 11 : ASSOCIATION MAPPING
------------------------------
Sommaire : 
1/ Le concept
2/ La Documentation de Doctrine
3/ mise en place de l'association Mapping (OneToMany) pour Membre -> Commande
-----------------------------

1/ Avec Doctrine, on a pris l'habitude de travailler avec des objets (Entity) correspondant aux enregistrements dans la BDD (Mapping).

L'association Mapping nous permet de travailler avec des objets dans des objets. Exemple : Un membre peut avoir plusieurs commandes, dans ce cas, dans un objet Membre nous avons un array compos√© d'objets commande. Une commande appartient √† UN membre, dans ce cas dans un objet Commande nous avons un objet membre. 

Gr√¢ce √† ce fonctionnement il est plus n√©cessaire de faire des requ√™tes de jointure, lorsqu'on r√©cup√®re un objet, on r√©cup√®re tous les objets li√©s. 

2/ 
https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/association-mapping.html#association-mapping


3/ mise en place de l'association Mapping (OneToMany) pour Membre -> Commande
	
		-> Entity Membre
		-> Entity Commande

		
		-> Dans la vue list_commande.html.twig, on utilise {{ c.membre.prenom }} pour acc√©der aux infos du membre qui a pass√© la commande. 




--------------------------------------------------------
ETAPE 12 : SECURITE ET UTILISATION
-------------------------------------------------------
Sommaire :
1. Niveau de s√©curit√©
2. Fichier de s√©curit√©
3. Creation des routes
4. Classe Membre (extends UserInterface)
5. layout




1. Niveau de s√©curit√©

    - De base Symfony va consid√©rer un visiteur lambda comme un anonyme.
    - Ensuite on va d√©finir des niveaux de s√©curit√© pour les utilisaterus connect√© : 
        - ROLE_USER (user connect√©)
        - ROLE_ADMIN ()
        - ROLE_SUPER_ADMIN

    - SF a un systeme de parefeu :

        - On d√©finit les routes que les ROLE peuvent emprunter.

        -> Si un user anonyme --> homepage = OK
        -> Si un user anonyme --> profil = pas OK -> connexion
        -> Si un user connect√© --> profil = OK
        -> Si un user connect√© --> admin/produit = pas OK --> page erreur (404)

        EN fonction du visiteur et de la ressources demand√©e on peut param√©trer une r√©action.


2/ Fichier de s√©curit√©

	<code>app/config/security.yml
	
	On d√©finie plusieurs choses : 
	- encoders (la mani√®re dont les password seront encod√©s)
	- provider (quelle ressource va servir d'utilisateur : MembreEntity, le login: username)
	- Hierarchie : La pyramide des droits
	- les routes form_login et logout (voir le point suivant)
	- Access control : qui a le droit √† quoi


	/!\ Attention le YAML est tr√®s sensible aux indentations et aux espaces. 
	





3/ Creation des routes
	
	form_login: 
		login_path: connexion (page de connexion)
		
		check_path: connexion_check (Page de checking de login/password, on doit juste la cr√©√©e, et la mettre dans l'attribut action de notre formulaire de connexion)
		
		default_target_path: homepage (La page par d√©faut sur laquelle on est dirig√© une fois connect√©. Sinon le parefeu prend le dessus)

	logout:
		path: deconnexion (La route de deconnexion. Doit exister mais est vide)
		target: homepage (page de destination, lorsqu'on se d√©connecte). 
		


4/ Classe Membre (extends UserInterface)
	
	- A partir de maintenant la classe Membre doit implements l'interface UserInterface
		
		
	--> username (getter/setter)
	--> password (getter/setter)
	--> roles (getter/setter) /!\ roles est un array 
	--> salt (getter/setter)
	
	/!\ Attention lors de l'inscription, il faut penser √† d√©finir un role_user par d√©faut. 
	
	--> public function eraseCredentials() : fonction obligatoire pour que SF prenne la main. 
	
	--> getRoles() et setRoles() au pluriel obligatoirement. 


5/ Layout

	Dans les vues on fait la distinction entre le niveau d'acces des utilisateur avec : 
		
	{{ if is_granted('IS_AUTHENTICATED_FULLY') }}  : tout le monde (sauf anonyme)
	{{ if is_granted('ROLE_USER') }}  : tous les users
	{{ if is_granted('ROLE_ADMIN') }}  : tous les admin
	
		
		
===> Le salage (cf salt.php) c'est l'id√©e de rendre un MDP quasiment inviolable en ajoutant au MDP soit une cha√Æne de caract√®re que seul le d√©veloppeur connait (petit site, petite structure), ou alors une cha√Æne al√©atoire pour chaque user... Ensuite pour la connexion, on r√©cup√®re le salage, pour reconstituer le MDP complet.




---------------------		
ETAPE 13 : Symfony 4		
Sommaire :
1/ Installation
2/ L'architecture
3/ Lancement de l'app
4/ Le maker
5/ Flex
-------------------


1/ installation : 
composer create-project symfony/website-skeleton Boutique4

2/ L'architecture

	- app a disparu  ----> config 
	- src/AppBundle a disparu   ---->  BundleLess sans Bundle mais toujours dans le namespace App\
	- src/Resources/ View  a disparu  ---> templates
		
	Le dossier templates prendra toutes les vues (Produit/ Admin/ Membres/ Bases) ainsi que le layout.html.twig
	
	web/ a disparu (app_dev.php, app.php, JS/CSS/Photo) ----> public (index.php, JS/CSS/Photo etc...)
	
	.env : Notre config (notamment les infos de connexion √† la bdd
	
3/ Lancement de l'app

	<cmd>
	php bin/console server:start
		ou alors
	php bin/console server:run
		
		
4/ Le maker : 		

	- Cr√©ation des Entit√©s : 
		php bin/console make:entity
		
		ou depuis la BDD : 
		php bin/console doctrine:mapping:import "App\Entity" annotation --path=src/Entity

			
	- Mise √† jours des entit√©s :
		php bin/console make:Entity --regenerate
		

	- Cr√©er les controller : 
		php bin/console make:controller 
		ProduitController 
		MembreController 
		CommandeController
		BaseController
		AdminController

	- Cr√©er les CRUD : 
		- pre-requis : Copier/coller les entit√©s
		
		copier le dossier	 boutique3/src/AppBundle/Entity
		le coller dans le dossier	boutique4/src/
	
	
		<cmd>
		php bin/console make:crud
		Membre
		Commande
		Produit
		
		
	- Cr√©er l'entit√© Membre : 
		<cmd>
	php bin/console make:user
	
	
		
Bundle : 

	- FOSUserBundle 
	- easyAdmin 
	
Flex : 

Symfony Flex : la nouvelle fa√ßon de d√©velopper avec Symfony
Les versions de Symfony 3.4 et 4.0 viennent tout juste de sortir et avec elles vient une nouvelle fa√ßon de d√©velopper des applications Symfony. D√Ætes adieu √† la Standard Edition et bonjour aux tout nouveaux symfony/skeleton, Symfony Flex et les recettes qui vont avec.

Vous avez dit Flex ?
D‚Äôun point de vue technique, Symfony Flex est juste un plugin Composer. Il se branche sur les √©v√©nements Composer d√®s lors que vous lancez une commande qui installe, met √† jour ou supprime un paquet PHP ou bundle Symfony. Son but ? Automatiser l‚Äôinstallation et la suppression de vos d√©pendances en fournissant une configuration par d√©faut sans avoir √† aller lire la doc pour trouver quelle configuration √©crire, quelles routes charger ou autre t√¢che r√©barbative √† effectuer. Et d√®s Symfony 4.0, Flex sera le moyen par d√©faut pour d√©velopper une application Symfony.

Il para√Æt qu‚Äôun bon exemple vaut mieux qu‚Äôun long discours. Alors imaginons que vous ayez une application existante en Symfony 3.3 (parce que vous √™tes un dev cool et avez effectu√© les migrations vers les derni√®res versions de Symfony au fur et √† mesure üí™). Vous voulez y ajouter une API en installant api-platform. Vous allez donc effectuer les t√¢ches suivantes :
	
	
Sources : https://afsy.fr/avent/2017/08-symfony-flex-la-nouvelle-facon-de-developper-avec-symfony


WebPack Encore : 
https://symfony.com/doc/current/frontend.html
	

